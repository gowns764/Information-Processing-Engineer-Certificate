# 자주 출제 되는 것

## 1장 요구사항 확인

### 1. 폭포수 모형
- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.

### 2. 나선형 모형
- 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형이다.
- 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가

### 3. XP
- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.
- 핵심 가치
  - 의사소통
  - 단순성
  - 용기
  - 존중
  - 피드백

### 5. XP의 주요 실천 방법
- **Pair Programming** (짝 프로그래밍)
  - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성한다.
- **Collective Ownership** (공동 코드 소유)
  - 개발 코드에 대한 권한과 책임을 공동으로 소유한다.
- **Test-Driven Development** (테스트 주도 개발)
  - 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로, 무엇을 해야 할지를 정확히 파악한다.
  - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구를 사용한다.
- **Whole Team** (전체 팀)
  - 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임감을 가져야 한다.
- **Continous Integration** (계속적인 통합)
  - 모듈 단위로 나눠서 개발된 코드를은 하나의 작업이 마무리 될 때마다 지속적으로 통합된다.
- **Refactoring** (리팩토링)
  - 프로그램 기능의 변경 없이 시스템을 재구성한다.
  - 목적 : 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
- **Small Releases** (소규모 릴리즈)
  - 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다.

### 6. 구조적 분석 기법
- 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법이다.
- 주요 구조적 분석 도구 기법 종류
  - **자료 흐름도 (DFD)**
  - **자료 사전 (DD)**
  - 소단위 명세서 (Mini-Spec.)
  - 개체 관계도 (ERD)
  - 상태 전이도 (STD)
  - 제어 명세서

### 7. 자료 흐름도 (DFD)
- 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법이다.
- 기본 기호
  - **프로세스**
    - 자료를 변환시키는 시스템의 한 부분을 나타내며 처리, 기능, 변환, 버블이라고도 한다.
  - **자료 흐름**
    - 자료의 이동이나 연관 관계를 나타낸다.
  - **자료 저장소**
    - 시스템에서의 자료 저장소를 나타낸다.
  - **단말**
    - 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받는다.

### 8. 자료 사전 (DD)
- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이다.
- 표기 기호
  - =
    - 자료의 정의
  - \+
    - 자료의 연결
  - ( )
    - 자료의 생략
  - 대괄호
    - 자료의 선택
  - { }
    - 자료의 반복
  - \* \*
    - 자료의 설명

### 9. UML(Unified Modeling Language)
- 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어이다.
- UML의 구성 요소
  - **사물**
  - **관계**
  - **다이어그램**

### 10. 소프트웨어 개발 표준
- **ISO/IEC 12207**
  - ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스이다.
  - 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.
- **CMMI**
    - 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델이다.
- **SPICE**
    - 정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준이다.

## 2장 데이터 입출력 구현

### 1. 관계형 데이터베이스의 릴레이션 구조
- **튜플**
  - 릴레이션을 구성하는 각각의 행을 말한다.
  - 속성의 모임으로 구성된다.
  - 파일 구조에서 레코드와 같은 의미이다.
  - 튜플의 수를 카디널리티 또는 기수, 대응수라고 한다.
- **속성**
  - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
  - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
  - 개체의 특성을 기술한다.
  - 속성의 수를 디그리 또는 차수라고 한다.
- **도메인**
  -  하나의 속성이 취할 수 있는 같은 타입의 원자 값들의 집합이다.
  -  실제 속성 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.

### 2. 순수 관계 연산자
- **Select**
  - 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산이다.
  - 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다.
- **Project**
  - 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이다.
  - 연산 결과에 중복이 발생하면 중복이 제거된다.
  - 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자로고도 한다.
- **Join**
  - 공통 속성을 중심으로 두 갸의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산이다.
  - Join의 결과는 교차곱을 수행한 다음 Select를 수행한 것과 같다.
- **Division**
  - X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산이다.

### 3. 정규화
- 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정이다.
- 정규화의 목적은 사능한 한 중복은 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다.

### 4. 뷰
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다.
- 장단점
  - 장점
    - 논리적인 데이터 독립성을 제공한다.
    - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해준다.
    - 사용자의 데이터 관리를 간단하게 해준다.
    - 접근 제어를 통한 자동 보안이 제공된다.
  - 단점
    - 독립적인 인덱스를 가질 수 없다.
    - 뷰의 정의를 변경할 수 없다.
    - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다.

### 5. 파티션
- 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.
- 데이터 처리는 테이블 단위로 이루어지고, 데이터 저장은 파티션별로 수행된다.
- 종류
  - **범위 분할**
    - 지정한 열의 값을 기준으로 분할한다.
  - **해시 분할**
    - 해시 함수를 적용한 결과 값에 따라 데이터를 분할한다.
    - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용하다.
    - 특정 데이터가 어디에 있는지 판단할 수 없다.
    - 데이터가 고른 컬럼에 효과적이다.
  - **조합 분할**
    - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식이다.
    - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용하다.

### 6. 분산 데이터베이스의 목표
- **위치 투명성**
  - 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다.
- **중복 투명성**
  - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.
- **병행 투명성**
  - 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
- **장애 투명성**
  - 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

### 7. 접근통제
- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다.
- 접근통제의 3요소
  - **접근통제 정책**
  - **접근통제 메커니즘**
  - **접근통제 보안 모델**
- 접근통제 기술
  - **임의 접근통제** (DAC)
    - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식이다.
    - 데이터 쇼유자가 접근통제 권한을 지정하고 제어한다.
  - **강제 접근통제** (MAC)
    - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식이다.
    - 시스템이 접근통제 권한을 지정한다.
  - **역할 기반 접근통제** (RBAC)
    - 사용자의 역할에 따라 접근 권하는 부여하는 방식이다.
    - 중앙관리자가 접근통제 권한을 지정한다.

## 4장 서버 프로그램 구현

### 1. 럼바우의 분석 기법
- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법이다.
- 객체 모델링 기법(OMT)이라고도 한다.
- 분석 활동 순서
    1. **객체 모델링**
       - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
    2. **동적 모델링**
       - 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링이다.
    3. **기능 모델링**
       - 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.

### 2. 배치 프로그램
- 사용자와의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램을 의미한다.
- 배치 프로그램의 필수 요소
  - **대용량 데이터**
    - 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 한다.
  - **자동화**
    - 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 한다.
  - **견고성**
    - 잘못된 데이터나 데이터 중복 등의 상황으로는 중단되는 일 없이 수행되어야 한다.
  - **안전성/신뢰성**
    - 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 한다.
  - **성능**
    - 다른 응용 프로그램의 수행을 방해하지 않아야 한다.
    - 지정된 시간 내에 처리가 완료되어야 한다.

## 5장 인터페이스 구현

### 1. 요구사항 검증 방법
- **요구사항 검토**
  - 요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법이다.
  - 종류
    - **동료 검토**
      - 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법이다.
    - **워크 스루**
      - 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법이다.
    - **인스펙션**
      - 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법이다.
- **프로토타이핑**
  - 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측한다.
- **테스트 설계**
  - 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지를 검토한다.
- **CASE 도구 활용**
  - 일관성 분석을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준 준수 여부를 확인한다.

### 2. 인터페이스 보안 기능 적용
- 일반적으로 네트워크, 애플리케이션, 데이터베이스 영역에 적용한다.
  - **네트워크 영역**
    - 인터페이스 송수신 간 스니핑 등을 이용한 데이터 탕취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정한다.
  - **애플리케이션 영역**
    - 소프트웨어 개발 보안 가이드를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 애플리케이션 보안 기능을 적용한다.
  - **데이터베이스 영역**
    - 데이터베이스, 스키마, 엔티티 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용한다.

### 3. 인터페이스 구현 검증 도구
- **xUnit**
  - JAVA, C++, .Net 등 다양한 언어들 지원하는 단위 테스트 프레임워크이다.
- **STAF**
  - 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이다.
  - 크로스 플랫폼이나 분산 소프트웨어에서 테스트 환경을 조성할 수 있도록 지원한다.
- **FitNesse**
  - 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.
- **NTAF**
  - FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크이다.
- **Selenium**
  - 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크이다.
- **Watir**
  - Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.

## 7장 애플리케이션 테스트 관리

### 1. 프로그램 실행 여부에 따른 테스트
- **정적 테스트**
  - 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트이다.
  - 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용한다.
  - 종류
    - 워크스루, 인스펙션, 코드 검사 등
- **동적 테스트**
  - 프로그램을 실행하여 오류를 찾는 테스트이다.
  - 소프트웨어 개발의 모든 단계에서 테스트를 수행한다
  - 동류
    - 블랙박스 테스트, 화이트박스 테스트

### 2. 화이트 박스 테스트
- 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법이다.
- 모듈 안의 작동을 직접 관찰한다.
- 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행된다.
- 종류
  - **기초 경로 검사**
    - 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법이다.
    - 대표적인 화이트박스 테스트 기법이다.
  - **제어 구조 검사**
    - **조건 검사**
      - 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법이다.
    - **루프 검사**
      - 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법이다.
    - **데이터 흐름 검사**
      - 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법이다.

### 3. 테스트 오라클
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동을 말한다.
- 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인한다.
- 특징
  - **제한된 검증**
    - 테스트 오라클을 모든 테스트 케이스에 적용할 수 없다.
  - **수학적 검증**
    - 테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있다.
  - **자동화 검증**
    - 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있다.
- 종류
  - **참 오라클**
    - 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클이다.
    - 발생된 모든 오류를 검출할 수 있다.
  - **추정 오라클**
    - 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클이다.
  - **일관성 검사 오라클**
    - 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클이다.

### 4. 클린 코드 작성 원칙
- **가독성**
  - 누구든지 코드를 쉽게 읽을 수 있도록 작성한다.
  - 코드 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용한다.
- **단순성**
  - 코드를 간단하게 작성한다.
  - 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리한다.
- **의존성 배제**
  - 코드가 다른 모듈에 미치는 영향을 최소화한다.
  - 코드 변경 시 다른 부분에 영향이 없도록 작성한다.
- **중복성 최소화**
  - 코드의 중복을 최소화한다.
  - 중복된 코드는 삭제하고 공통된 코드를 사용한다.
- **추상화**
  - 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현한다.

## 8장 SQL 응용

### 1. SQL - DDL (Data Define Language, 데이터 정의어)
- DDL은 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어이다.
- 번역한 결과가 데이터 사전이라는 특별한 파일에 여러 개의 테이블로 저장된다.
- DDL의 3가지 유형
  - **CREATE**
    - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의한다.
  - **ALTER**
    - TABLE에 대한 정의를 변경하는 데 사용한다.
  - **DROP**
    - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제한다.

### 2. SQL - DCL (Data Control Language, 데이터 제어어)
- DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어이다.
- 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용한다.
- DCL의 종류
  - **COMMIT**
    - 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려준다.
  - **ROLLBACK**
    - 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구한다.
  - **GRAINT**
    - 데이터베이스 사용자에게 사용 권한을 부여한다.
  - **REVOKE**
    - 데이터베이스 사용자의 사용 권한을 취소한다.

### 3. SQL - DML (Data Manipulation Language, 데이터 조작어)
- DML은 데이터베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다.
- 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.
- DML의 유형
  - **SELECT**
    - 테이블에서 튜플을 검색한다.
  - **INSERT**
    - 테이블에 새로운 튜플을 삽입한다.
  - **DELETE**
    - 테이블에서 튜플을 삭제한다.
  - **UPSATE**
    - 테이블에서 튜플의 내용을 갱신한다.

### 4. DML - SELECT-1
```
SELECT [PREDICATE [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...]
[, 그룹함수(속성명) [AS 별칭]]
[, Window함수 OVER (PARTITION BY 속성명1, 속성명2, ...
                ORDER BY 속성명3, 속성명4, ...)]
FROM 테이블명[, 테이블명, ...]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ...]
[ORDER BY 속성명 [ASC | DESC]];
```
- **SELECT절**
  - PREDICATE
    - 검색할 튜플 수를 제한하는 명령어를 기술한다.
    - DISTINCT
      - 중복된 튜플이 있으면 그 중 첫 번째 한 개만 표시한다.
  - 속성명
    - 검색하여 불러올 속성(열) 또는 속성을 이용한 수식을 지정한다.
  - AS
    - 속성이나 연산의 이름을 다른 이름으로 표시하기 위해 사용한다.
- **FROM절**
  - 검색할 데이터가 들어있는 테이블 이름을 기술한다.
- **WHERE절**
  - 검색할 조건을 기술한다.
- **ORDER BY절**
  - 데이터를 정렬하여 검색할 때 사용한다.
  - 속성명
    - 정렬의 기준이 되는 속성명을 기술한다.
    - [ASC | DESC]
      - 정렬 방식으로, 'ASC'는 오름차순, 'DESC'는 내림차순이다.
      - 생략하면 오름차순으로 지정된다.

### 5. DML - SELECT-2
```
SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...]
[, 그룹함수(속성명) [AS 별칭]]
[, WINDOW함수 OVER (PARTITION BY 속성명1, 속성명2, ...
              ORDER BY 속성명3, 속성명4, ...) [AS 별칭]]
FROM 테이블명[, 테이블명, ...]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ...]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
```
- **그룹 함수**
  - GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술한다.
- **WINDOW 함수**
  - GROUP BY절을 이용하지 않고 속성의 값을 집계할 함수를 기술한다.
  - PARTITION BY
    - WINDOW 함수의 적용 범위가 될 속성을 지정한다.
  - ORDER BY
    - PARTITION 안에서 정렬 기준으로 사용할 속성을 지정한다.
- **GROUP BY절**
  - 특정 속성을 기준으로 그룹화하여 검색할 때 사용한다.
  - 일반적으로  GROUP BY절은 그룹 함수와 함께 사용된다.
- **HAVING절**
  - GROUP BY와 함께 사용되며, 그룹에 대한 조건을 지정한다.

## 9장 소프트웨어 개발 보안 구축

### 1. 서비스 공격 유형
- **DoS 공격**
  - 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적인 기능을 방해하는 것이다.
- **Ping of Death**
  - 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법이다.
- **SMURFING**
  - IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법이다.
- **SYN FLOODING**
  - TCP는 신뢰성 있는 전송을 위해3-way-handshake를 거친 후에 데이터를 전송하게 되는데, SYN Flooding은 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법이다.
- **TearDrop**
  - 데이터의 송수신 과정에서 패킷의 크기가 커서 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, TearDrop은 이 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부화를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법이다.
- **DDoS**
  - 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것이다.
  - 네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트로 만든 후 DDoS 공격에 이용한다.

## 11장 응용 SW 기초 기술 활용

### 1. 경로 제어 프로토콜(Routing Protocol)
- **IGP(내부 게이트웨이 프로토콜)**
  - **RIP**
    - 거리 벡터 라우팅 프로토콜이라고도 불린다.
    - 소규모 동종의 네트워크 내에서 효율적인 방법이다.
- **EGP(외부 게이트웨이 프로토콜)**
  - 게이트웨이 간의 라우팅에 사용되는 프로토콜이다.
- **BGP**
  - EGP의 단점을 보완하기 위해 만들어졌다.
  - 초기에 BGP 라우터들이 연결될 때에는 전체 라우팅 테이블을 교환하고, 이후에는 변화된 정보만을 교환한다.

### 6. 회복
- 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 대 손상되기 이전의 상태로 복구하는 작업이다.
- 종류
  - **연기 갱신 방법**
    - 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법이다.
  - **그림자 페이지 대체 기법**
    - 갱신 이전의 데이터베이스를 일정 크기의 페이지 간위로 구성하여 각 페이지마다 복사본인 그림자 페이지를 별도 보관해 놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 롤백시킬 대는 갱신 이루의 실제 페이지 부분을 그림자 페이지로 대체하여 회복시키는 기법이다.
  - **검사점 기법**
    - 트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 수행하여 회복 시간을 절약하도록 하는 기법이다.

### 7. 병행제어
- 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것이다.
- 종류
  - **로킹**
    - 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock을 요청해서 Lock이 허락되어야만 그 로길 단위를 액세스할 수 있도록 하는 기법이다.
  - **타임 스탬프 순서**
    - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법이다.
  - **최적 병행 수행**
    - 병행 수행하고자 하는 대부분의 트랜잭션들이 판독 전용 트랜잭션일 경우, 트랜잭션 간의 퉁돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법이다.
  - **다중 버전 기법**
    - 타임 스탬프의 개념을 이용하는 기법이다.
    - 갱신될 때마다의 버전을 부여하여 관리한다.

### 8. 로킹 단위
- 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미한다.
- 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있다.
- 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다.
- 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아진다.

### 9. 교착상태 발생의 필요 충분 조건
- **상호 배제**
  - 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
- **점유와 대기**
  - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
- **비선점**
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
- **환형 대기**
  - 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.

### 10. 교착상태의 해결 방법
- **예방 기법**
  - 교착 상태가 발생하지 않도록 사전에 시스템을 제어하는 방법이다.
- **회피 기법**
  - 교착 상태가 발생할 가능성을 배제하지 않고 교착 상태가 발생하면 적절히 피해나가는 방법이다.
- **발견 기법**
  - 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것이다.
- **회복 기법**
  - 교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것이다.

## 12장 제품 소프트웨어 패키징

### 1. DRM의 흐름 및 구성 요소
- **클리어링 하우스**
  - 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳이다.
- **콘텐츠 제공자**
  - 콘텐츠를 제공하는 저작권자이다.
- **패키저**
  - 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램이다.
- **콘텐츠 분배자**
  - 암호화된 콘텐츠를 유통하는 곳이나 사람이다.
- **콘텐츠 소비자**
  - 콘텐츠를 구매해서 사용하는 주체이다.
- **DRM 컨트롤러**
  - 배포된 콘텐츠의 이용 권한을 통제하는 프로그램이다.
- **보안 컨테이너**
  - 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치이다.

### 2. DRM의 기술 요소
- **암호화**
  - 콘텐츠 및 라인선스를 암호화하고 전자서명을 할 수 있는 기술이다.
- **키 관리**
  - 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술이다.
- **암호화 파일 생성**
  - 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술이다.
- **식별 기술**
  - 콘텐츠에 대한 식별 체계 표현 기술이다.
- **저작권 표현**
  - 라이선스의 내용 표현 기술이다.
- **정책 관리**
  - 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술이다.
- **크랙 방지**
  - 크랙에 의한 콘텐츠 사용 방지 기술이다.
- **인증**
  - 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술이다.

### 3. 형상 관리 기능
- **형상 식별**
  - 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업이다.
- **버전 제어**
  - 소프트웨어 업그레이드나 유지보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구를 결합시키는 작업이다.
- **형상 감사**
  - 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업이다.
- **형상 기록**
  - 형상의 식별, 통제, 감사 작업의 결과를 기록·관리하고 보고서를 작성하는 작업이다.

### 4. 소프트웨어의 버전 등록 관련 주요 기능
- **저장소(Repository)**
  - 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳이다.
- **가져오기(Import)**
  - 버전 관리가 되고 있지 않은 아무 것도 없는 저장소에 처음으로 파일을 복사한다.
- **체크아웃(Check-Out)**
  - 프로그램을 수정하기 위해 저장소에서 파일을 받아온다.
  - 소스 파일들과 함께 버전 관리를 위한 파일들도 받아온다.
- **체크인(Check-In)**
  - 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신한다.
- **커밋(Commit)**
  - 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료한다.
- **동기화(Update)**
  - 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화한다.