# 자주 출제 되는 것

## 1장 요구사항 확인

### 1. 폭포수 모형
- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.

### 2. 나선형 모형
- 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형이다.
- 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가

### 3. 애자일 모형
- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형이다.
- 폭포수 모형과 대조적이다.
- 대표적인 개발 모형
  - **스크럼**
  - **XP**
  - **칸반**
  - **Lean**
  - **기능 중심 개발(FDD)**

### 4. XP
- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.
- 핵심 가치
  - 의사소통
  - 단순성
  - 용기
  - 존중
  - 피드백

### 5. XP의 주요 실천 방법
- **Pair Programming** (짝 프로그래밍)
  - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성한다.
- **Collective Ownership** (공동 코드 소유)
  - 개발 코드에 대한 권한과 책임을 공동으로 소유한다.
- **Test-Driven Development** (테스트 주도 개발)
  - 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로, 무엇을 해야 할지를 정확히 파악한다.
  - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구를 사용한다.
- **Whole Team** (전체 팀)
  - 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임감을 가져야 한다.
- **Continous Integration** (계속적인 통합)
  - 모듈 단위로 나눠서 개발된 코드를은 하나의 작업이 마무리 될 때마다 지속적으로 통합된다.
- **Refactoring** (리팩토링)
  - 프로그램 기능의 변경 없이 시스템을 재구성한다.
  - 목적 : 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
- **Small Releases** (소규모 릴리즈)
  - 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다.

### 6. 구조적 분석 기법
- 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법이다.
- 주요 구조적 분석 도구 기법 종류
  - **자료 흐름도 (DFD)**
  - **자료 사전 (DD)**
  - 소단위 명세서 (Mini-Spec.)
  - 개체 관계도 (ERD)
  - 상태 전이도 (STD)
  - 제어 명세서

### 7. 자료 흐름도 (DFD)
- 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법이다.
- 기본 기호
  - **프로세스**
    - 자료를 변환시키는 시스템의 한 부분을 나타내며 처리, 기능, 변환, 버블이라고도 한다.
  - **자료 흐름**
    - 자료의 이동이나 연관 관계를 나타낸다.
  - **자료 저장소**
    - 시스템에서의 자료 저장소를 나타낸다.
  - **단말**
    - 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받는다.

### 8. 자료 사전 (DD)
- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이다.
- 표기 기호
  - =
    - 자료의 정의
  - \+
    - 자료의 연결
  - ( )
    - 자료의 생략
  - 대괄호
    - 자료의 선택
  - { }
    - 자료의 반복
  - \* \*
    - 자료의 설명

### 9. UML(Unified Modeling Language)
- 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어이다.
- UML의 구성 요소
  - **사물**
  - **관계**
  - **다이어그램**

### 10. 소프트웨어 개발 표준
- **ISO/IEC 12207**
  - ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스이다.
  - 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.
- **CMMI**
    - 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델이다.
- **SPICE**
    - 정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준이다.

## 2장 데이터 입출력 구현

### 1. 스키마
- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
- 종류
  - **외부 스키마**
    - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터 베이스의 논리적인 구조를 정의한 것이다.
  - **개념 스키마**
    - 데이터베이스의 전체적인 논리적 구조이다.
    - 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재한다.
  - **내부 스키마**
    - 물리적 저장장치의 입장에서 본 데이터베이스 구조이다.
    - 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.

### 2. 관계형 데이터베이스의 릴레이션 구조
- **튜플**
  - 릴레이션을 구성하는 각각의 행을 말한다.
  - 속성의 모임으로 구성된다.
  - 파일 구조에서 레코드와 같은 의미이다.
  - 튜플의 수를 카디널리티 또는 기수, 대응수라고 한다.
- **속성**
  - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
  - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
  - 개체의 특성을 기술한다.
  - 속성의 수를 디그리 또는 차수라고 한다.
- **도메인**
  -  하나의 속성이 취할 수 있는 같은 타입의 원자 값들의 집합이다.
  -  실제 속성 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.

### 3. 순수 관계 연산자
- **Select**
  - 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산이다.
  - 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 한다.
- **Project**
  - 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이다.
  - 연산 결과에 중복이 발생하면 중복이 제거된다.
  - 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자로고도 한다.
- **Join**
  - 공통 속성을 중심으로 두 갸의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산이다.
  - Join의 결과는 교차곱을 수행한 다음 Select를 수행한 것과 같다.
- **Division**
  - X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산이다.

### 4. 이상
- 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 중복으로 인해 데이블 조작 시 문제가 발생하는 현상을 의미한다.
- 종류
  - **삽입 이상**
    - 테이블에 데이터를 삽입할 때 의도와는 상괍 없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상이다.
  - **삭제 이상**
    - 테이블에서 한 튜플을 삭제할 때 의도와는 상관 없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상이다.
  - **갱신 이상**
    - 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 생신되어 정보의 불일치성이 생기는 현상이다.

### 5. 정규화
- 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정이다.
- 정규화의 목적은 사능한 한 중복은 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다.

### 6. 반정규화
- 시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위이다.
- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.
- 과도한 반정규화는 오히려 성능을 저하시킬 수 있다.
- 반정규화의 방법
  - **테이블 통합**
  - **테이블 분할**
  - **중복 테이블 추가**
  - **중복 속성 추가**

### 7. 트랜잭션
- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.
- 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적인 단위로 사용된다.
- 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용된다.
- 특성
  - **원자성** (Atomicity)
    - 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료되든지 아니면 반영되지 않도록 복구되어야 한다.
  - **일관성** (Consistency)
    - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
  - **독립성** (Isolation)
    - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
  - **영속성** (Durability)
    - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

### 8. 뷰
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
- 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다.
- 장단점
  - 장점
    - 논리적인 데이터 독립성을 제공한다.
    - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해준다.
    - 사용자의 데이터 관리를 간단하게 해준다.
    - 접근 제어를 통한 자동 보안이 제공된다.
  - 단점
    - 독립적인 인덱스를 가질 수 없다.
    - 뷰의 정의를 변경할 수 없다.
    - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다.

### 9. 파티션
- 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.
- 데이터 처리는 테이블 단위로 이루어지고, 데이터 저장은 파티션별로 수행된다.
- 종류
  - **범위 분할**
    - 지정한 열의 값을 기준으로 분할한다.
  - **해시 분할**
    - 해시 함수를 적용한 결과 값에 따라 데이터를 분할한다.
    - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용하다.
    - 특정 데이터가 어디에 있는지 판단할 수 없다.
    - 데이터가 고른 컬럼에 효과적이다.
  - **조합 분할**
    - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식이다.
    - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용하다.

### 10. 분산 데이터베이스의 목표
- **위치 투명성**
  - 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다.
- **중복 투명성**
  - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.
- **병행 투명성**
  - 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
- **장애 투명성**
  - 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

### 11. RTO/RPO
- **RTO** (Recovery Time Objective, 목표 복구 시간)
  - 비상 사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미한다.
- **RPO** (Recovery Point Objective,  목표 복구 시점)
  - 비상 사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미한다.

### 12. 접근통제
- 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다.
- 접근통제의 3요소
  - **접근통제 정책**
  - **접근통제 메커니즘**
  - **접근통제 보안 모델**
- 접근통제 기술
  - **임의 접근통제** (DAC)
    - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식이다.
    - 데이터 쇼유자가 접근통제 권한을 지정하고 제어한다.
  - **강제 접근통제** (MAC)
    - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식이다.
    - 시스템이 접근통제 권한을 지정한다.
  - **역할 기반 접근통제** (RBAC)
    - 사용자의 역할에 따라 접근 권하는 부여하는 방식이다.
    - 중앙관리자가 접근통제 권한을 지정한다.

### 13. 트리 관련 용어
- **노드** (Node)
  - 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것이다.
- **근 노드** (Root Node)
  - 트리의 맨 위에 있는 노드이다.
- **차수** (Degree)
  - 각 노드에서 뻗어나온 가지의 수이다,
- **단말 노드, 잎 노드** (Terminal Node, Leaf Node) 
  - 자식이 하나도 없는 노드, 즉 디그리가 0인 노드이다.
- **비단말 노드** (Non-Terminal Node)
  - 자식이 하나라도 있는 노드, 즉 디그리가 0이 아닌 노드이다.
- **조상 노드** (Ancestord Node)
  - 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들이다.
- **자식 노드** (Son Node)
  - 어떤 노드에 연결된 다음 레벨의 노드들이다.
- **부모 노드** (Parent Node)
  - 어떤 노드에 연결된 이전 레벨의 노드들이다.
- **형제 노드** (Brother Node, Sibling)
  - 동일한 부모를 갖는 노드들이다.
- **Level**
  - 근 노드들의 Level을 1로 가정한 후, 어떤 Level이 L이면 자식 노드는 L+1이다.
- **깊이** (Depth, Height) 
  - 트리에서 노드가 가질 수 있는 최대 레벨이다.
- **숲** (Forest)
  - 여러 개의 트리가 모여 있는 것이다.
- **트리의 디그리**
  - 노드들의 디그리 중에서 가장 많은 수이다.

## 4장 서버 프로그램 구현

### 1. 럼바우의 분석 기법
- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법이다.
- 객체 모델링 기법(OMT)이라고도 한다.
- 분석 활동 순서
    1. **객체 모델링**
       - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
    2. **동적 모델링**
       - 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링이다.
    3. **기능 모델링**
       - 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.

### 2. 결합도
- 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계이다.
- 결합도가 약할 수록 품질이 높고, 강할 수록 품질이 낮다.
- 종류
  - **내용 결합도**
    - 한 모듈이 다른 모듈 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다.
  - **공통(공유) 결합도**
    - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다.
  - **외부 결합도**
    - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도이다.
  - **제어 결합도**
    - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도이다.
    - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생한다.
  - **스탬프(검인) 결합도**
    - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.
  - **자료 결합도**
    - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도이다.

### 3. 응집도
- 모듈의 내부 요소들이 서로 관련되어 있는 정도이다.
- 응집도가 강할 수록 품질이 높고, 약할 수록 품질이 낮다.

### 4. 디자인 패턴
- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.
- 종류
  - **생성 패턴**
    - 클래스나 객체의 생성과 참조 과정을 정의하는 패턴이다.
  - **구조 패턴**
    - 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴이다.
  - **행위 패턴**
    - 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.

### 5. 배치 프로그램
- 사용자와의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램을 의미한다.
- 배치 프로그램의 필수 요소
  - **대용량 데이터**
    - 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 한다.
  - **자동화**
    - 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 한다.
  - **견고성**
    - 잘못된 데이터나 데이터 중복 등의 상황으로는 중단되는 일 없이 수행되어야 한다.
  - **안전성/신뢰성**
    - 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 한다.
  - **성능**
    - 다른 응용 프로그램의 수행을 방해하지 않아야 한다.
    - 지정된 시간 내에 처리가 완료되어야 한다.

## 5장 인터페이스 구현

### 1. 요구사항 검증 방법
- **요구사항 검토**
  - 요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법이다.
  - 종류
    - **동료 검토**
      - 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법이다.
    - **워크 스루**
      - 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법이다.
    - **인스펙션**
      - 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법이다.
- **프로토타이핑**
  - 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측한다.
- **테스트 설계**
  - 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지를 검토한다.
- **CASE 도구 활용**
  - 일관성 분석을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준 준수 여부를 확인한다.

### 2. EAI(Enterprise Application Integration)
- 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션이다.
- EAI의 구축 유형
  - **Point-to-Point**
    - 가장 기본적인 애플리케이션 통합 방식이다.
    - 애플리케이션을 1:1로 연결한다.
    - 변경 및 재사용이 어렵다.
  - **Hub & Spoke**
    - 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식이다.
    - 확장 및 유지 보수가 용이하다.
    - 허브 장애 발생 시 시스템 전체에 영향을 미친다.
  - **Message Bus** (ESB 방식)
    - 애플리케이션 사이에 미들웨어를 두어 처리하는 방식이다.
    - 확장성이 뛰어나며 대용량 처리가 가능하다.
  - **Hybrid**
    - Hub & Spoke와 Message Bus의 혼합 방식이다.
    - 그롭 내에서는 Hub & Spoke 방식을, 그룹 간에는 Message Bus 방식을 사용한다.
    - 필요한 경우 한 가지 방식으로 EAI 구현이 가능하다.
    - 데이터 병목 현상을 최소화할 수 있다.

### 3. 인터페이스 보안 기능 적용
- 일반적으로 네트워크, 애플리케이션, 데이터베이스 영역에 적용한다.
  - **네트워크 영역**
    - 인터페이스 송수신 간 스니핑 등을 이용한 데이터 탕취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정한다.
  - **애플리케이션 영역**
    - 소프트웨어 개발 보안 가이드를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 애플리케이션 보안 기능을 적용한다.
  - **데이터베이스 영역**
    - 데이터베이스, 스키마, 엔티티 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용한다.

### 4. 인터페이스 구현 검증 도구
- **xUnit**
  - JAVA, C++, .Net 등 다양한 언어들 지원하는 단위 테스트 프레임워크이다.
- **STAF**
  - 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크이다.
  - 크로스 플랫폼이나 분산 소프트웨어에서 테스트 환경을 조성할 수 있도록 지원한다.
- **FitNesse**
  - 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다.
- **NTAF**
  - FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크이다.
- **Selenium**
  - 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크이다.
- **Watir**
  - Ruby를 사용하는 애플리케이션 테스트 프레임워크이다.

## 6장 화면 설계

### 1. 사용자 인터페이스의 기본 원칙
- **직관성**
  - 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- **유효성**
  - 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
- **학습성**
  - 누구나 쉽게 배우고 익힐 수 있어야 한다.
- **유연성**
  - 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

## 7장 애플리케이션 테스트 관리

### 1. 프로그램 실행 여부에 따른 테스트
- **정적 테스트**
  - 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트이다.
  - 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용한다.
  - 종류
    - 워크스루, 인스펙션, 코드 검사 등
- **동적 테스트**
  - 프로그램을 실행하여 오류를 찾는 테스트이다.
  - 소프트웨어 개발의 모든 단계에서 테스트를 수행한다
  - 동류
    - 블랙박스 테스트, 화이트박스 테스트

### 2. 화이트 박스 테스트
- 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법이다.
- 모듈 안의 작동을 직접 관찰한다.
- 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행된다.
- 종류
  - **기초 경로 검사**
    - 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법이다.
    - 대표적인 화이트박스 테스트 기법이다.
  - **제어 구조 검사**
    - **조건 검사**
      - 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법이다.
    - **루프 검사**
      - 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법이다.
    - **데이터 흐름 검사**
      - 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법이다.

### 3. 블랙박스 테스트
- 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 한다.
- 사용자의 요구사항 명세를 보면서 테스트한다.
- 주로 구현된 기능을 테스트한다.
- 소프트웨어 인터페이스를 통해 실시된다.
- 종류
  - **동치 분할 검사**
    - 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법이다.
  - **경계 값 분석**
    - 입력 조건의 중갑 값보다 경계 값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계 값을 테스트 케이스로 선정하여 검사하는 기법이다.
  - **원인-효과 그래프 검사**
    - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법이다.
  - **오류 예측 검사**
    - 과거의 경험이나 확인자의 감각으로 테스트하는 기법이다.
  - **비교 검사**
    - 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법이다.

### 4. 테스트 오라클
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동을 말한다.
- 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인한다.
- 특징
  - **제한된 검증**
    - 테스트 오라클을 모든 테스트 케이스에 적용할 수 없다.
  - **수학적 검증**
    - 테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있다.
  - **자동화 검증**
    - 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있다.
- 종류
  - **참 오라클**
    - 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클이다.
    - 발생된 모든 오류를 검출할 수 있다.
  - **샘플링 오라클**
    - 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용한다.
  - **추정 오라클**
    - 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클이다.
  - **일관성 검사 오라클**
    - 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클이다.

### 5. 클린 코드 작성 원칙
- **가독성**
  - 누구든지 코드를 쉽게 읽을 수 있도록 작성한다.
  - 코드 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용한다.
- **단순성**
  - 코드를 간단하게 작성한다.
  - 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리한다.
- **의존성 배제**
  - 코드가 다른 모듈에 미치는 영향을 최소화한다.
  - 코드 변경 시 다른 부분에 영향이 없도록 작성한다.
- **중복성 최소화**
  - 코드의 중복을 최소화한다.
  - 중복된 코드는 삭제하고 공통된 코드를 사용한다.
- **추상화**
  - 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현한다.

## 8장 SQL 응용

### 1. SQL - DDL (Data Define Language, 데이터 정의어)
- DDL은 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어이다.
- 번역한 결과가 데이터 사전이라는 특별한 파일에 여러 개의 테이블로 저장된다.
- DDL의 3가지 유형
  - **CREATE**
    - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의한다.
  - **ALTER**
    - TABLE에 대한 정의를 변경하는 데 사용한다.
  - **DROP**
    - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제한다.

### 2. SQL - DCL (Data Control Language, 데이터 제어어)
- DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어이다.
- 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용한다.
- DCL의 종류
  - **COMMIT**
    - 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려준다.
  - **ROLLBACK**
    - 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구한다.
  - **GRAINT**
    - 데이터베이스 사용자에게 사용 권한을 부여한다.
  - **REVOKE**
    - 데이터베이스 사용자의 사용 권한을 취소한다.

### 3. SQL - DML (Data Manipulation Language, 데이터 조작어)
- DML은 데이터베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다.
- 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.
- DML의 유형
  - **SELECT**
    - 테이블에서 튜플을 검색한다.
  - **INSERT**
    - 테이블에 새로운 튜플을 삽입한다.
  - **DELETE**
    - 테이블에서 튜플을 삭제한다.
  - **UPSATE**
    - 테이블에서 튜플의 내용을 갱신한다.

### 4. DML - SELECT-1
```
SELECT [PREDICATE [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...]
[, 그룹함수(속성명) [AS 별칭]]
[, Window함수 OVER (PARTITION BY 속성명1, 속성명2, ...
                ORDER BY 속성명3, 속성명4, ...)]
FROM 테이블명[, 테이블명, ...]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ...]
[ORDER BY 속성명 [ASC | DESC]];
```
- **SELECT절**
  - PREDICATE
    - 검색할 튜플 수를 제한하는 명령어를 기술한다.
    - DISTINCT
      - 중복된 튜플이 있으면 그 중 첫 번째 한 개만 표시한다.
  - 속성명
    - 검색하여 불러올 속성(열) 또는 속성을 이용한 수식을 지정한다.
  - AS
    - 속성이나 연산의 이름을 다른 이름으로 표시하기 위해 사용한다.
- **FROM절**
  - 검색할 데이터가 들어있는 테이블 이름을 기술한다.
- **WHERE절**
  - 검색할 조건을 기술한다.
- **ORDER BY절**
  - 데이터를 정렬하여 검색할 때 사용한다.
  - 속성명
    - 정렬의 기준이 되는 속성명을 기술한다.
    - [ASC | DESC]
      - 정렬 방식으로, 'ASC'는 오름차순, 'DESC'는 내림차순이다.
      - 생략하면 오름차순으로 지정된다.

### 5. DML - SELECT-2
```
SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...]
[, 그룹함수(속성명) [AS 별칭]]
[, WINDOW함수 OVER (PARTITION BY 속성명1, 속성명2, ...
              ORDER BY 속성명3, 속성명4, ...) [AS 별칭]]
FROM 테이블명[, 테이블명, ...]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ...]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
```
- **그룹 함수**
  - GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술한다.
- **WINDOW 함수**
  - GROUP BY절을 이용하지 않고 속성의 값을 집계할 함수를 기술한다.
  - PARTITION BY
    - WINDOW 함수의 적용 범위가 될 속성을 지정한다.
  - ORDER BY
    - PARTITION 안에서 정렬 기준으로 사용할 속성을 지정한다.
- **GROUP BY절**
  - 특정 속성을 기준으로 그룹화하여 검색할 때 사용한다.
  - 일반적으로  GROUP BY절은 그룹 함수와 함께 사용된다.
- **HAVING절**
  - GROUP BY와 함께 사용되며, 그룹에 대한 조건을 지정한다.

## 9장 소프트웨어 개발 보안 구축

### 1. 소프트웨어 개발 보안 요소
- **기밀성**
- **무결성**
- **가용성**
- **인증**
- **부인 방지**

### 2. 서비스 공격 유형
- **DoS 공격**
  - 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적인 기능을 방해하는 것이다.
- **Ping of Death**
  - 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법이다.
- **SMURFING**
  - IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법이다.
- **SYN FLOODING**
  - TCP는 신뢰성 있는 전송을 위해3-way-handshake를 거친 후에 데이터를 전송하게 되는데, SYN Flooding은 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법이다.
- **TearDrop**
  - 데이터의 송수신 과정에서 패킷의 크기가 커서 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, TearDrop은 이 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부화를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법이다.
- **LAND Attack**
  - 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송하는 것으로, 이 패킷을 받은 공격 대상은 송신 IP 주소가 자신이므로 자신에게 응답을 수행하게 되는데, 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답하게 하는 공격이다.
- **DDoS**
  - 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것이다.
  - 네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트로 만든 후 DDoS 공격에 이용한다.

## 11장 응용 SW 기초 기술 활용

### 1. 프로세스 상태 전이
- 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미한다.
- 상태
  - **제출(Submit)**
  - **접수(Hold)**
  - **준비(Ready)**
  - **실행(Run)**
  - **대기(Wait), 블록(Block)**
  - **종료(Terminated, Exit)**

### 2. HRN(Hightest Response-rario Next)
- 대기 시간과 서비스(실행) 시간을 이용하는 기법이다.
- 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것이다.
- 우선 순위를 계산하여 그 숫자가 가장 노ㅠ은 것부터 낮은 순으로 우선 순위가 부여된다.
- 우선 순위 계산식
  - **(대기 시간 + 서비스 시간) / 서비스 시간**

### 3. 프로토콜
- 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약이다.
- 기본 요소
  - **구문(Syntax)**
    - 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정한다.
  - **의미(Semantics)**
    - 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정한다.
  - **시간(Timing)**
    - 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정한다.

### 4. NAT(Network Address Translation, 네트워크 주소 변환)
- 한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소를 할당 및 연결하는 기능이다.
- 한 개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 한 개로 제한되는 문제가 있지만 IP 마스커레이드를 이용하여 해결할 수 있다.

### 5. 경로 제어 프로토콜(Routing Protocol)
- **IGP(내부 게이트웨이 프로토콜)**
  - **RIP**
    - 거리 벡터 라우팅 프로토콜이라고도 불린다.
    - 소규모 동종의 네트워크 내에서 효율적인 방법이다.
  - **OSPF**
    - RIP의 단점을 해결하여 새로운 기능을 지원하는 인터넷 프로토콜로, 대규모 네트워크에서 많이 사용된다.
    - 인터넷 망에서 이용자가 최단 경로를 선정할 수 있도록 라우팅 정보에 노드 간의 거리 정보, 링크 상태 정보를 실시간으로 반영하여 최단 경로로 라우팅을 지원한다.
    - 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내의 모든 라우터에 알린다.
- **EGP(외부 게이트웨이 프로토콜)**
  - 게이트웨이 간의 라우팅에 사용되는 프로토콜이다.
- **BGP**
  - EGP의 단점을 보완하기 위해 만들어졌다.
  - 초기에 BGP 라우터들이 연결될 때에는 전체 라우팅 테이블을 교환하고, 이후에는 변화된 정보만을 교환한다.

### 6. 회복
- 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 대 손상되기 이전의 상태로 복구하는 작업이다.
- 종류
  - **연기 갱신 방법**
    - 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법이다.
  - **즉각 갱신 방법**
    - 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법이다.
  - **그림자 페이지 대체 기법**
    - 갱신 이전의 데이터베이스를 일정 크기의 페이지 간위로 구성하여 각 페이지마다 복사본인 그림자 페이지를 별도 보관해 놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 롤백시킬 대는 갱신 이루의 실제 페이지 부분을 그림자 페이지로 대체하여 회복시키는 기법이다.
  - **검사점 기법**
    - 트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 수행하여 회복 시간을 절약하도록 하는 기법이다.

### 7. 병행제어
- 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것이다.
- 종류
  - **로킹**
    - 트랜잭션들이 어떤 로킹 단위를 액세스하기 전에 Lock을 요청해서 Lock이 허락되어야만 그 로길 단위를 액세스할 수 있도록 하는 기법이다.
  - **타임 스탬프 순서**
    - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법이다.
  - **최적 병행 수행**
    - 병행 수행하고자 하는 대부분의 트랜잭션들이 판독 전용 트랜잭션일 경우, 트랜잭션 간의 퉁돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법이다.
  - **다중 버전 기법**
    - 타임 스탬프의 개념을 이용하는 기법이다.
    - 갱신될 때마다의 버전을 부여하여 관리한다.

### 8. 로킹 단위
- 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미한다.
- 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있다.
- 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다.
- 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아진다.

### 9. 교착상태 발생의 필요 충분 조건
- **상호 배제**
  - 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
- **점유와 대기**
  - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
- **비선점**
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
- **환형 대기**
  - 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.

### 10. 교착상태의 해결 방법
- **예방 기법**
  - 교착 상태가 발생하지 않도록 사전에 시스템을 제어하는 방법이다.
- **회피 기법**
  - 교착 상태가 발생할 가능성을 배제하지 않고 교착 상태가 발생하면 적절히 피해나가는 방법이다.
- **발견 기법**
  - 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것이다.
- **회복 기법**
  - 교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것이다.

## 12장 제품 소프트웨어 패키징

### 1. DRM의 흐름 및 구성 요소
- **클리어링 하우스**
  - 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳이다.
- **콘텐츠 제공자**
  - 콘텐츠를 제공하는 저작권자이다.
- **패키저**
  - 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램이다.
- **콘텐츠 분배자**
  - 암호화된 콘텐츠를 유통하는 곳이나 사람이다.
- **콘텐츠 소비자**
  - 콘텐츠를 구매해서 사용하는 주체이다.
- **DRM 컨트롤러**
  - 배포된 콘텐츠의 이용 권한을 통제하는 프로그램이다.
- **보안 컨테이너**
  - 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치이다.

### 2. DRM의 기술 요소
- **암호화**
  - 콘텐츠 및 라인선스를 암호화하고 전자서명을 할 수 있는 기술이다.
- **키 관리**
  - 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술이다.
- **암호화 파일 생성**
  - 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술이다.
- **식별 기술**
  - 콘텐츠에 대한 식별 체계 표현 기술이다.
- **저작권 표현**
  - 라이선스의 내용 표현 기술이다.
- **정책 관리**
  - 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술이다.
- **크랙 방지**
  - 크랙에 의한 콘텐츠 사용 방지 기술이다.
- **인증**
  - 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술이다.

### 3. 소프트웨어 패키징의 형상 관리
- 형상 관리(SCM)는 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동이다.
- 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행된다.
- 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.

### 4. 형상 관리 기능
- **형상 식별**
  - 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업이다.
- **버전 제어**
  - 소프트웨어 업그레이드나 유지보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구를 결합시키는 작업이다.
- **형상 통제**
  - 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업이다.
- **형상 감사**
  - 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업이다.
- **형상 기록**
  - 형상의 식별, 통제, 감사 작업의 결과를 기록·관리하고 보고서를 작성하는 작업이다.

### 5. 소프트웨어의 버전 등록 관련 주요 기능
- **저장소(Repository)**
  - 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳이다.
- **가져오기(Import)**
  - 버전 관리가 되고 있지 않은 아무 것도 없는 저장소에 처음으로 파일을 복사한다.
- **체크아웃(Check-Out)**
  - 프로그램을 수정하기 위해 저장소에서 파일을 받아온다.
  - 소스 파일들과 함께 버전 관리를 위한 파일들도 받아온다.
- **체크인(Check-In)**
  - 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신한다.
- **커밋(Commit)**
  - 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료한다.
- **동기화(Update)**
  - 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화한다.