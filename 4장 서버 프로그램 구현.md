# 4장 서버 프로그램 구현 (7%)

## 1. 소프트웨어 아키텍쳐
- 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다.
- 소프트웨어 아키텍쳐 설계의 기본 원리에는 모듈화, 추상화, 단계적 분해, 정보 은닉이 있다.

### 1.1. 모듈화
- 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간 통합 비용이 많이 든다.
- 모듈의 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.

### 1.2. 추상화
- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.
- 완전한 시스템의 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다.
- 추상화의 유형
  - **과정 추상화**
    - 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법이다.
  - **데이터 추상화**
    - 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법이다.
  - **제어 추상화**
    - 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법이다.

### 1.3. 단계적 분해
- 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.
- 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.

### 1.4. 정보 은닉
- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.
- 정보 은닉을 통해 모듈을 족립적으로 수행할 수 있다.
- 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.

### 1.5. 상위 설계와 하위 설계
||**상위 설계**|**하위 설계**|
|:-:|:-:|:-:|
|별칭|아키텍쳐 설계, 예비 설계|모듈 설계, 살세 설계|
|설계 대상|시스템의 전반적인 구조|시스템의 내부 구조 및 행위|
|세부 목록|구조, DB, 인터페이스|컴포넌트, 자료 구조, 알고리즘|

### 1.6. 소프트웨어 아키텍쳐의 품질 속성
- 소프트웨어 아키텍쳐가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화시켜 놓은 것이다.
- 품질 평가 요소의 종류
  - **시스템 측면**
    - 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
  - **비즈니스 측면**
    - 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등
  - **아키텍쳐 측면**
    - 개념적 무결성, 정확성, 구축 가능성, 변경성, 시험성 등

### 1.7. 소프트웨어 아키텍쳐의 설계 과정
1. **설계 목표 설정**
2. **시스템 타입 결성**
3. **아키텍쳐 패턴 적용**
4. **서브시스템 구체화**
5. **검토**

### 1.8. 협약에 의한 설계
- 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것이다.
- 컴포넌트에 대한 정확한 인터페이스를 명세한다.
- 명세에 포함될 조건
  - **선행 조건**
    - 오퍼레이션이 호출되기 전에 참이 되어야 할 조건이다.
  - **결과 조건**
    - 오퍼레이션이 수행된 후 만족되어야 할 조건이다.
  - **불변 조건**
    - 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건이다.

## 2. 아키텍쳐 패턴
- 아키텍쳐를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다.
- 아키텍쳐 패턴에는 서브시스템들과 그 역할이 정의되어 있다.
- 서브시스템 사이의 관계와 여러 규칙 • 지침 등이 포함되어 있다.
- 주요 아키텍쳐 패턴의 종류
  - **레이어 패턴**
  - **클라이언트-서버 패턴**
  - **파이프-필터 패턴**
  - **모댈-뷰-컨트롤러 패턴**

### 2.1. 레이어 패턴
- 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴이다.
- 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다.
- 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다.
- 대표적으로 OSI 참조 모델이 있다.

### 2.2. 클라이언트-서버 패턴
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다.
- 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식이다.

### 2.3. 파이프-필터 패턴
- 데이터 스트링 절차와 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴이다.
- 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복한다.
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.
- 대표적으로 UNIX의 쉘이 있다.

### 2.4. 모델-뷰-컨트롤러 패턴
- 서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴이다.
- 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조이다.
- 여러 개의 뷰를 만들 수 있다.
- 한 개의 모델에 대하 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.

## 3. 객체지향
- 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법이다.
- 객체지향의 구성 요소
  - **객체**
  - **클래스**
  - **메시지**
- 객체지향의 특징
  - **캡슐화**
  - **상속**
  - **다형성**
  - **연관성**

### 3.1. 객체
- 데이터와 이를 처리하기 위한 함수를 묵어 놓은 소프트웨어 모듈이다.
  - **데이터**
    - 객체가 가지고 있는 정보로, 속성이나 상태, 분류 등이다.
  - **함수**
    - 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘이다.
    - 객체의 상태를 참조하거나 변경하는 수단이다.

### 3.2. 클래스
- 공통된 속성과 연산을 갖는 객체의 집합이다.
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
- 클래스에 속한 각각의 객체를 인스턴스라고 한다.

### 3.3. 메시지
- 객체들 간의 상호작용에 사용되는 수단으로, 객체의 동작이나 연산을 일으키는 외부의 요구 사항이다.
- 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환한다.

### 3.4. 캡슐화
- 외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것이다.
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적다.

### 3.5. 상속
- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.

### 3.6. 다형성
- 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력이다.

### 3.7. 연관성
- 두 개 이상의 객체들이 상호 참조하는 관계를 의미한다.

## 4. 객체지향 분석 및 설계

### 4.1. 객체지향 분석 (OOA)
- 사용자의 요구 사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업이다.
- 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다.
- 클래스를 식별하는 것이 객체지향 분석의 주요 목적이다.

### 4.3. 럼바우의 분석 기법
- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법이다.
- 객체 모델링 기법(OMT)이라고도 한다.
- 분석 활동 순서
    1. **객체 모델링**
       - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
    2. **동적 모델링**
       - 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링이다.
    3. **기능 모델링**
       - 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.

### 4.4. 객체지향 설계 원칙
- 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙이다.
- 객체지향 설계 원칙의 종류
  - **단일 책임 원칙 (SRP)**
    - 객체는 단 하나의 책임만 가져야 한다는 원칙이다.
  - **개방-폐쇄 원칙 (OCP)**
    - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙이다.
  - **리스코프 치환 원칙 (LSP)**
    - 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙이다.
  - **인터페이스 분리 원칙 (ISP)**
    - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙이다.
  - **의존 역전 원칙 (DIP)**
    - 의존 관계 성입 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙이다.

## 5. 모듈 <출제돰>
- 모듈화를 통해 분리된 시스템의 각 기능으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미한다.
- 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미한다.
- 모듈의 독립성은 결합도와 응집도에 의해 측정된다.

### 5.1. 결합도 <출제됨>
- 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계이다.
- 결합도가 약할 수록 품질이 높고, 강할 수록 품질이 낮다.

#### 5.1.1. 결합도의 종류 <출제됨>
- **내용 결합도**
  - 한 모듈이 다른 모듈 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다.
- **공통(공유) 결합도**
  - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다.
- **외부 결합도**
  - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도이다.
- **제어 결합도**
  - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도이다.
  - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생한다.
- **스탬프(검인) 결합도**
  - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.
- **자료 결합도**
  - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도이다.

### 5.2. 응집도 <출제됨>
- 모듈의 내부 요소들이 서로 관련되어 있는 정도이다.
- 응집도가 강할 수록 품질이 높고, 약할 수록 품질이 낮다.

#### 5.2.1. 응집도의 종류
- **기능적 응집도**
  - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도이다.
- **순차적 응집도**
  - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도이다.
- **교환(통신)적 응집도**
  - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도이다.
- **절차적 응집도**
  - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 모였을 경우의 응집도이다.
- **시간적 응집도**
  - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도이다.
- **논리적 응집도**
  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도이다.
- **우연적 응집도**
  - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도이다.

### 5.3. 팬인(Fan-In) / 팬아웃(Fan-Out)
- **팬인**
  - 어떤 모듈을 제어하는 모듈의 수이다.
  - 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있다.
  - 팬인이 높은 경우 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다.
- **팬아웃**
  - 어떤 모듈에 의해 제어되는 모듈의 수이다.

### 5.4. N-S 차트
- 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법이다.
- GOTO나 화살표를 사용하지 않는다.
- 연속, 선택 및 다중 선택, 반복의 3가지 제어 논리 구조로 표현한다.
- 조건이 복합되어 있는 곳의 처리를 시작적으로 명확히 식별하는 데 적합하다.

## 6. 공통 모듈
- 여러 프로그램에서 공통으로 사용할 수 있는 모듈이다.
- 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성될 수 있다.
- 공통 모듈을 구현할 때는 해당 기능을 명확히 이해할 수 있도록 명세 기법을 준수해야 한다.

### 6.1. 공통 모듈 명세 기법의 종류
- **정확성**
  - 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성한다.
- **명확성**
  - 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성한다.
- **완전성**
  - 시스템 구현을 위해 필요한 모든 것을 기술한다.
- **일관성**
  - 공통 기능들 간 상호 충돌이 발생하지 않도록 작성한다.
- **추적성**
  - 기능에 대한 요구 사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성한다.

### 6.2. 재사용
- 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업이다.
- 새로 개발하는데 필요한 비용과 시간을 절약할 수 있다.
- 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 한다.
- 재사용 규모에 따른 분류
  - **함수와 객체**
    - 클래스나 메소드 단위의 소스 코드를 재사용한다.
  - **컴포넌트**
    - 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용한다.
  - **애플리케이션**
    - 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용한다.

### 6.3. 효과적인 모듈 설계 방안
- 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
- 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
- 모듈의 기능은 예측 가능해야 하며 지나치게 제한적이어서는 안 된다.
- 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.
- 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 한다.

## 7. 코드
- 자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호이다.
- 정보를 신속 • 정확 • 명료하게 전달할 수 있게 한다.
- 일정한 규칙에 따라 작성된다.
- 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다.

### 7.1. 코드의 주요 기능
- **식별 기능**
  - 데이터 간의 성격에 따라 구분이 가능하다.
- **분류 기능**
  - 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있다.
- **배열 기능**
  - 의미를 부여하여 나열할 수 있다.
- **표준화 기능**
  - 다양한 데이터를 기준에 맞추어 표현할 수 있다.
- **간소화 기능**
  - 복잡한 데이터를 간소화할 수 있다.

### 7.2. 코드의 종류
- **순차 코드**
  - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 한다.
- **블록 코드**
  - 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 한다.
- **10진 코드**
  - 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 한다.
- **그룹 분류 코드**
  - 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법이다.
- **연상 코드**
  - 코드화 대상 항목의 명칭이나 약호와 관계 있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법이다.
- **표의 숫자 코드**
  - 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수피를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 한다.
- **합성 코드**
  - 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법이다.

## 8. 디자인 패턴
- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.
- 생성 패턴, 구조 패턴, 행위 패턴으로 구분된다.

### 8.1. 생성 패턴
- 클래스나 객체의 생성과 참조 과정을 정의하는 패턴이다.
  - **추상 팩토리**
    - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 • 읜존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
  - **빌더**
    - 작게 분리된 인스턴스를 조랍하여 객체를 생성한다.
  - **팩토리 메소드**
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
  - **프로토 타입**
    - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
  - **싱글톤**
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.

### 8.2. 구조 패턴
- 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴이다.
  - **어댑터**
  - **브릿지**
  - **컴포지트**
  - **데코레이터**
  - **퍼싸드**
  - **플라이웨이트**
  - **프록시**

### 8.3. 행위 패턴
- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.
  - **책임 연쇄**
    - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다.
  - **커맨드**
    - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴이다.
  - **인터프리터**
    - 언어에 문법 표현을 정의하는 패턴이다.
  - **반복자**
    - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.
  - **중재자**
    - 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴이다.
  - **메멘토**
    - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴이다.
  - **옵저버**
    - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴이다.
  - **상태**
    - 객체의 상테에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴이다.
  - **전략**
    - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.
  - **탬플릿 메소드**
    - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다.
  - **방문자**
    - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴이다.

## 9. 배치 프로그램
- 사용자와의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램을 의미한다.
- 배치 프로그램의 필수 요소
  - **대용량 데이터**
    - 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 한다.
  - **자동화**
    - 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 한다.
  - **견고성**
    - 잘못된 데이터나 데이터 중복 등의 상황으로는 중단되는 일 없이 수행되어야 한다.
  - **안전성/신뢰성**
    - 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 한다.
  - **성능**
    - 다른 응용 프로그램의 수행을 방해하지 않아야 한다.
    - 지정된 시간 내에 처리가 완료되어야 한다.

### 9.1. 배치 스케줄러
- 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구이다.
- 배치 스케줄러의 종류
  - **스프링 배치**
    - 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능을 제공한다.
  - **Quartz**
    - 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리이다.
    - 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일관 처리 작업에 유연성을 제공한다.
  - **Cron**
    - 리눅스의 기본 스케줄러 도구이다.
    - Crontab 명령어를 통해 작업을 예약할 수 있다.