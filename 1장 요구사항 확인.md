# 1장 요구사항 확인

## 1. 소프트웨어 생명 주기
- 소프트웨어를 개발하기 위한 설꼐, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것이다.

### 1.1. 폭포수 모형
- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.

### 1.2. 프로토타입 모형
- 사용자의 요구사항을 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 모형이다.

### 1.3. 나선형 모형
- 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형이다.
- 계획 -> 분석 -> 개발 -> 평가

### 1.4. 애자일 모형
- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형이다.
- 폭포수 모형과 대조적이다.

## 2. 스크럼 기법
- 팀이 중심이 되어 개발의 효율성을 높이는 기법이다.

### 2.1. 스크럼 팀의 구성원과 역할
- **제품 책임자** (PO)
  - 요구사항이 담긴 백로그를 작성하는 주체이다.
  - 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사를 결정할 사람으로 선정한다.
- **스크럼 마스터** (SM)
  - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수핸한다.
- **개발팀** (DT)
  - 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발을 수행한다.

### 2.2. 스크럼 개발 프로세스
- 계획 -> 진행 -> 회의 -> 검토 -> 회고


## 3. XP(eXtreme Programming) 기법

### 3.1. XP
- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.
- 핵심 가치
  - 의사소통
  - 단순성
  - 용기
  - 존중
  - 피드백

### 3.2. XP 개발 프로세스
1. 릴리즈 계획 수립
2. 이리테이션 (주기)
3. 승인 검사
4. 소규모 릴리즈

### 3.3. XP의 주요 실천 방법
- **Pair Programming** (짝 프로그래밍)
  - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성한다.
- **Collective Ownership** (공동 코드 소유)
  - 개발 코드에 대한 권한과 책임을 공동으로 소유한다.
- **Test-Driven Development** (테스트 주도 개발)
  - 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로, 무엇을 해야 할지를 정확히 파악한다.
  - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구를 사용한다.
- **Whole Team** (전체 팀)
  - 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임감을 가져야 한다.
- **Continous Integration** (계속적인 통합)
  - 모듈 단위로 나눠서 개발된 코드를은 하나의 작업이 마무리 될 때마다 지속적으로 통합된다.
- **Refactoring** (리팩토링)
  - 프로그램 기능의 변경 없이 시스템을 재구성한다.
  - 목적 : 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함이다.
- **Small Releases** (소규모 릴리즈)
  - 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다.

## 4. 개발 기술 환경 파악

### 4.1. 운영체제
- 컴퓨터 시스템의 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어이다.
- OS 관련 요구사항 식별시 고려사항
  - 가용성
  - 성능
  - 기술 지원
  - 주변 기기
  - 구축 비용

### 4.2. 데이터베이스 관리 시스템 (DBMS)
- 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어이다.
- DBMS 관련 요구사항 식별 시 고려사항
  - 성능
  - 기술 지원
  - 상호 호환성
  - 구축 비용
  
### 4.3. 웹 애플리케이션 서버 (WAS)
- 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.
- WAS 관련 요구사항 식별 시 고려사항
  - 가용성
  - 성능
  - 기술 지원
  - 구축 비용

### 4.4. 오픈 소스
- 누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어이다.
- 오픈 소스 관련 요구사항 식별 시 고려사항
  - 라이선스의 종류
  - 사용자 수
  - 기술의 지속 가능성

## 5. 요구사항 정의
- **요구사항**은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건이다.
- 요구사항의 유형
  - **기능 요구사항**
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항이다.
  - **비기능 요구사항**
    - 품질이나 제약사항과 관련된 요구사항이다.
  - **사용자 요구사항**
    - 사용자 관점에서 본 시스템이 제공해야 할 요구사항이다.
  - **시스템 요구사항**
    - 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항이다.

## 6. 요구사항 개발 프로세스
- 개발 대상에 대한 요구사항을 체계적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활동이다.
- 도출 -> 분석 -> 명세 -> 확인

### 6.1. 요구사항 도출
- 시스템, 사용자, 개발자 등 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정이다.
- 요구사항을 도출하는 주요 기법
  - 청취와 인터뷰
  - 설문
  - 브레인스토밍
  - 워크샵
  - 프로토타이핑
  - 유스케이스
  
### 6.2. 요구사항 분석
- 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정이다.

### 6.3. 요구사항 명세
- 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것을 의미한다.

### 6.4. 요구사항 확인
- 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동이다.

### 6.5. 요구공학
- 무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문이다.

## 7. 요구사항 분석
- 소프트웨어 개발의 실제적인 첫 단계로, 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동을 의미한다.

### 7.1. 구조적 분석 기법
- 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법이다.
- 주요 구조적 분석 도구 기법 종류
  - 자료 흐름도 (DFD)
  - 자료 사전 (DD)
  - 소단위 명세서 (Mini-Spec.)
  - 개체 관계도 (ERD)
  - 상태 전이도 (STD)
  - 제어 명세서

#### 7.1.1. 자료 흐름도 (DFD)
- 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법이다.

##### 7.1.1.1. 자료 흐름도 기본 기호
- **프로세스**
  - 자료를 변환시키는 시스템의 한 부분을 나타내며 처리, 기능, 변환, 버블이라고도 한다.
- **자료 흐름**
  - 자료의 이동이나 연관 관계를 나타낸다.
- **자료 저장소**
  - 시스템에서의 자료 저장소를 나타낸다.
- **단말**
  - 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받는다.

#### 7.1.2. 자료 사전 (DD)
- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이다.

## 8. 요구사항 분석 CASE와 HIPO

### 8.1. 요구사항 분석용 CASE (자동화 도구)
- 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기록하도록 개발된 도구를 의미한다.
- 대표적인 요구사항 분석용 CASE
  - **SADT**
    - 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구이다.
    - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구이다.
  - **SREM = RSL/REVS**
    - 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 도구이다.
  - **PSL/PSA**
    - PSL과 PSA를 사용하는 자동화 도구이다.
  - **TAGS**
    - 시스템 공학 방법 응용에 대한 자동 접근 방법이다.
    - 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구이다.

### 8.2. HIPO (Hierarchy Input Process Output)
- 시스템의 분석 및 설계, 또는 문서화에 사용되는 기법으로, 시스템 실행 과정인 입력 • 처리 • 출력의 기능을 표현한 것이다.
- 하향식 소프트웨어 개발을 위한 문서화 도구이다.
- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
- HIPO Chart의 종류
  - 가시적 도표
  - 총체적 도표
  - 세부적 도표

## 9. UML의 개요
- 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어이다.
- UML의 구성 요소
  - **사물**
  - **관계**
  - **다이어그램**

### 9.1. 사물
- 다이어그램 안에서 관계가 형성될 수 있는 대상들을 말한다.
- 사물의 종류
  - **구조 사물**
  - **행동 사물**
  - **그룹 사물**
  - **주해 사물**

## 10. UML - 관계
- 사물과 사물 사이의 연관성을 표현하는 것이다.
- 관계의 종류
  - **연관 관계**
  - **집합 관계**
  - **포함 관계**
  - **일반화 관계**
  - **의존 관계**
  - **실체화 관계**

### 10.1. 연관 관계
- 2개 이상의 사물이 서로 연관되어 있는 관계
- 사물 사이를 실선으로 연결하여 표현한다.
- 방향성은 화살표로 표현한다.
- 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결한다.
- 다중도를 선 위에 표기한다.

### 10.2. 집합 관계
- 하나의 사물이 다른 사물에 포함되어 있는 관계이다.
- 포함하는 쪽과 포함되는 쪽은 서로 독립적이다.
- 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현한다.

### 10.3. 포함 관계
- 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계이다.
- 포함하는 쪽과 포함되는 쪽은 서로 독립될 수 없고 생명주기를 함께한다.
- 포함되는 쪽에서 포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현한다.

### 10.4. 일반화 관계
- 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계이다.
- 보다 일반적인 개볌을 상위(부모), 보다 구체적인 개념을 하위(자식)라고 부른다.
- 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현한다.

### 10.5. 의존 관계
- 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계이다.
- 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계이다.
- 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현한다.

### 10.6. 실체화 관계
- 사물이 할 수 있거나 해야 하는 기능으로, 서로를 그룹화 할 수 있는 관계이다.
- 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현한다.

## 11. UML - 다이어그램
- 사물과 관계를 도형으로 표현한 것이다.
- 여러 관점에서 가시화한 뷰를 제공함으로써 의사소통에 도움을 준다.
- 정적 모델링에서는 주로 구조적 다이어그램을 사용한다.
- 동적 모델링에서는 주로 행위 다이어그램을 사용한다.

### 11.1. 구조적 다이어그램의 종류
- **클래스 다이어그램**
  - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한다.
- **객체 다이어그램**
  - 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현한다.
  - 럼바우 객체지향 분석 기법에서 객체 모델링에 활용된다.
- **컴포넌트 다이어그램**
  - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현한다.
  - 구현 단계에서 사용된다.
- **배치 다이어그램**
  - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현한다.
  - 구현 단계에서 사용된다.
- **복합체 구조 다이어그램**
  - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현한다.
- **패키지 다이어그램**
  - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한다.

### 11.2. 행위 다이어그램의 종류
- **유스케이스 다이어그램**
  - 사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용한다.
  - 사용자와 사용 사례로 구성된다.
- **시퀀스 다이어그램**
  - 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현한다.
- **커뮤니케이션 다이어그램**
  - 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현한다.
- **상태 다이어그램**
  - 하나의 객체 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현한다.
- **활동 다이어그램**
  - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 수선에 따라 표현한다.
- **상호작용 개요 다이어그램**
  - 상호작용 다이어그램 간의 제어 흐름을 표현한다.
- **타이밍 다이어그램**
  - 객체 상태 변화와 시간 제약을 명시적으로 표현한다.

### 11.3. 스테레오 타입
- UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것이다.
- << >> 사이에 표현할 형태를 기술한다.
- 주로 표현되는 형태
  - **<\<include\>>**
    - 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우
  - **<\<extend\>>**
    - 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우
  - **<\<interface\>>**
    - 인터페이스를 정의하는 경우
  - **<\<exception\>>**
    - 예외를 정의하는 경우
  - **<\<constructor\>>**
    - 생성자 역할을 수행하는 경우

## 12. 유스케이스 다이어그램

### 12.1. 기능 모델링
- 사용자의 요구사항을 분석하여 개발될 시스템이 갖추어야 할 기능을 정리한 후, 사용자와 함께 정리된 내용을 공유하기 위해 그림으로 표현하는 것이다.
- 개발될 시스템의 전반적인 형태를 기능에 초점을 맞추어 표현한다.
- 기능 모델링의 종류
  - **유스케이스 다이어그램**
  - **활동 다이어그램**

### 12.2. 유스케이스 다이어그램
- 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것이다.
- 외부 요소와 시스템 간의 상호 작용을 확인할 수 있다.
- 사용자의 요구사항을 분석하기 위한 도구로 사용된다.
- 시스템의 범위를 파악할 수 있다.

### 12.3. 유스케이스 다이어그램의 구성 요소
- **시스템 / 시스템 범위**
  - 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현한 것이다.
- **액터**
  - 시스템과 상호작용을 하는 모든 외부요소이다.
  - 주로 사람이나 외부 시스템을 의미한다.
  - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당된다.
  - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있다.
- **유스케이스**
  - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능을 표현한 것이다.
- **관계**
  - 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있다.
  - 유스케이스에서 나타날 수 있는 관계
    - 포함 관계, 확장 관계, 일반화 관계

## 13. 활동(Activity) 다이어그램
- 사용자 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것이다.
- 하나의 유스케이스 안에서 혹은 유스케이스 사이에 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다.
- 자료 흐름도와 유사하다.

### 13.1. 활동 다이어그램의 구성 요소
- **액션 / 액티비티**
  - 액션 : 더 이상 분해할 수 없는 단일 작업이다.
  - 액티비티 : 몇 개의 액션으로 분리될 수 있는 작업이다.
- **시작 노드**
  - 액션이나 액티비티가 시작됨을 표현한 것이다.
- **종료 노드**
  - 액티비티 안의 모든 흐름이 종료됨을 표현한 것이다.
- **조건(판단) 노드**
  - 조건에 따라 제어의 흐름이 분리됨을 표현한 것이다.
  - 들어오는 제어 흐름은 한 개이고 나가는 제어 흐름은 여러 개이다.
- **병합 노드**
  - 여러 경로의 흐름이 하나로 합쳐짐을 표현한 것이다.
  - 들어오는 제어 흐름은 여러 개이고 나가는 제어 흐름은 한 개이다.
- **포크 노드**
  - 액티비티의 흐름이 분리되어 수행됨을 표현한 것이다.
  - 들어오는 액티비티 흐름은 한개이고 나가는 액티비티 흐름은 여러 개이다.
- **조인 노드**
  - 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현한 것이다.
  - 들어오는 액티비티 흐름은 여러 개이고 나가는 액티비티 흐름은 한 개이다.
- **스웜 레인**
  - 액티비티 수행을 담당하는 주체를 구분하는 선이다.
  - 가로 또는 세로 실선을 그어 구분한다.

## 14. 클래스 다이어그램

### 14.1. 정적 모델링
- 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것이다.
- 시스템에 의해 처리되거나 처리될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점에서 표현한다.
- 객체들을 클래스로 추상화하여 표현한다.

### 14.2. 클래스 다이어그램
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것이다.
- 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램이다.
- 시스템 구성 요소를 문서화하는 데 사용된다.

### 14.3. 클래스 다이어그램의 구성 요소
- **클래스**
  - 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현한 것이다.
  - 일반적으로 3개의 구획으로 나눠 이름, 속성, 오퍼레이션을 표기한다.
  - 속성
    - 클래스의 상태나 정보를 표현한다.
  - 오퍼레이션
    - 클래스가 수행할 수 있는 동작으로 함수라고도 한다.
- **제약 조건**
  - 속성에 입력될 값에 대한 제약 조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적는다.
  - 클래스 안에 제약 조건을 기술할 때는 중괄호를 이용한다.
- **관계**
  - 관계는 클래스와 클래스 사이의 연관성을 표현한다.
  - 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있다.

### 14.4. 연관 클래스
- 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스이다.
- 두 클래스의 연관 관계를 나나태는 선의 가운데로부터 점선을 연관 클래스로 이어 표시한다.
- 연관 클래스의 이름은 연관 관계의 이름을 이용해 지정한다.

## 15. 시퀀스 다이어그램

### 15.1. 동적 모델링
- 시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것이다.
- 시스템 내부 구성 요소들 간에 이루어지는 동작이라는 관점에서 표현한다.
- 시스템이 실행될 때 구성 요소들 간의 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둔다.
- 동적 모델링의 종류
  - **시퀀스 다이어그램**
  - **커뮤니케이션 다이어그램**
  - **상태 다이어그램**

### 15.2. 시퀀스 다이어그램
- 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것이다.
- 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현한다.
- 각 종작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있다.
- 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현한다.

### 15.3. 시퀀스 다이어그램의 구성 요소
- **액터**
  - 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미한다.
- **객체**
  - 메시지를 주고받는 주체이다.
- **생명선**
  - 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현한다.
  - 객체 소멸(X)이 표시된 기간까지 존재한다.
- **실행 상자**
  - 객체가 메시지를 주고받으며 구동되고 있음을 표현한다.
- **메시지**
  - 객체가 상호 작용을 위해 주고받는 메시지이다.
- **객체 소멸**
  - 해당 객체가 더 이상 메모리에 존재하지 않음을 표현한 것이다.
- **프레임**
  - 다이어그램의 전체 또는 일부를 묶어 표현한 것이다.

## 16. 패키지 다이어그램
- 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것이다.
- 패키지는 또 다른 패키지의 요소가 될 수 있다.
- 대규모 시스템에서 주요 요소 간의 종속성을 파악하는 데 사용한다.

### 16.1. 패키지 다이어그램의 구성 요소
- **패키지**
  - 객체들의 그룹화한 것이다.
  - 단순 표기법
    - 패키지 안에 이름만 표현한다.
  - 확장 표기법
    - 패키지 안에 요소까지 표현한다.
- **객체**
  - 우스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들이다.
- **의존 관계**
  - 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현한다.
    - 스테레오 타입을 이용하여 의존 관계를 구체적으로 표현할 수 있다.

## 17. 소프트웨어 개발 방법론
- 소프트웨어 개발, 유지보수 등에 필요하 여러가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것이다.
- 소프트웨어 개발 방법론의 목적은 소프트웨어의 생산성과 품질 향상이다.
- 주요 소프트웨어 개발 방법론
  - **구조적 방법론**
  - **정보공학 방법론**
  - **객체지향 방법론**
  - **컴포넌트 기반 방법론**
  - **제품 계열 방법론**
  - **애자일 방법론**

### 17.1. 구조적 방법론
- 정형화된 분석 절차에 따라 사용자의 요구사항을 파악하여 문서화하는 처리 중심의 방법론이다.
- 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적이다.
- 복잡한 문제를 다루기 위해 분한과 정복 원리를 적용한다.
- 구조적 방법론의 개발 절차
  - 타당성 검토 -> 계획 -> 요구사항 -> 설계 -> 구현 -> 시험 -> 운용/유지보수

### 17.2. 정보공학 방법론
- 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론이다.
- 정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합하다.
- 정보공학 방법론의 개발 절차
  - 정보 전략 계획 수립 -> 업무 영역 분석 -> 업무 시스템 설계 -> 업무 시스템 구축

### 17.3. 객체지향 방법론
- 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론이다.
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되었다.
- 객체지향 방법론의 구성 요소
  - 객체, 클래스, 메시지 등
- 객체지향 방법론의 개발 절차
  - 요구 분석 -> 설계 -> 구현 -> 테스트 및 검증 -> 인도

### 17.4. 컴포넌트 기반 방법론
- 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론이다.
- 컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있다.
- 새로운 기늘을 추가하는 것이 간단하여 확장성이 보장된다.
- 유지보수 비용을 최소화하고 생산성 및 품질을 향상시킬 수 있다.
- 컴포넌트 기반 방법론의 개발 절차
  - 개발 준비 -> 분석 -> 설계 -> 구현 -> 테스트 -> 전개 -> 인도

### 17.5. 제품 계열 방법론
- 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론이다.
- 임베디드 소프트웨어를 만드는데 적합하다.
- 제품 계열 방법론은 영역공학과 응용공학으로 구분된다.

## 18. S/W 공학의 발전적 추세

### 18.1. 소프트웨어 재사용
- 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것이다.
- 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법이다.
- 소프트웨어 재사용 방법
  - **합성 중십**
    - 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 한다.
  - **생성 중심**
    - 추상화 형태로 써진 명새를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 한다.

### 18.2. 소프트웨어 재공학
- 새로운 요구에 맞도록 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것이다.
- 소프트웨어 재공학의 이점
  - 소프트웨어의 품질 향상
  - 소프트웨어의 생산성 증가
  - 소프트웨어의 수명 연장
  - 소프트웨어의 오류 감소

### 18.3. CASE(Computer Aided Software Engineering)
- 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것이다.
- 객체지향 시스템, 구조적 시스템 등 가양한 시스템에서 활용되는 자동화 도구이다.
- 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합된 도구를 제공한다.
- CASE의 주요 기능
  - 소프트웨어 생명 주기 전 단계의 연결
  - 다양한 소프트웨어 개발 모형 지원
  - 그래픽 지원

## 19. 비용 산정 기법 - 하향식
- 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법이다.
- 프로젝트의 전체 비용을 산정한 후 각 작업별로 비용을 세분화한다.
- 하향식 비용 산정 기법
  - **전문가 감정 기법**
  - **델파이 기법**

### 19.1. 전문가 감정 기법
- 조직 내에 있는 경험이 많은 두 명 이상의 전문가에게 바용 산정을 의뢰하는 기법이다.
- 가장 편리하고 신속하게 비용을 산정할 수 있다.
- 개인적이고 주관적일 수 있다.

### 19.2. 델파이 기법
- 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법이다.
- 전문가들의 편견이나 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가로 구성된다.

## 20. 비용 산정 기법 - 상향식
- 프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법이다.
- 주요 상향식 비용 산정 기법
  - **LOC(원시 코드 라인 수) 기법**
  - **개발 단계별 인월수 기법**
  - **수학적 산정 기법**

### 20.1. LOC 기법
- 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법이다.
- 측정이 용이하고 이해하기 쉬워 가장 많이 사용된다.
- 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용을 산정한다.
  - **예측치 = (a+4m+b)/6** 단, a:낙관치, b:비관치, m:기대치
- 산정 공식
  - 노력 = 개발 기간 × 투입 인원 = LOC / 1인당 월평균 생산 코드 라인 수
  - 개발 비용 = 노력 × 단위 비용(1인당 월평균 인건비)
  - 개발 기간 = 노력 / 투입 인원
  - 생산성 = LOC / 노력

### 20.2. 개발 단계별 인월수 기법
- LOC 기법을 보완하기 위한 기법으로, 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정한다.
- LOC 기법보다 더 정확하다.

## 21. 수학적 산정 기법
- 상향식 비용 산정 기법으로, 경험적 추정 모형, 실험적 추정 모형이라고도 한다.
- 개발 비용 산정의 자동화를 목표로 한다.
- 비용의 자동 산정을 위해 사용되는 공식은 과거의 유사한 프로젝트를 기반으로 유도된 것이다.
- 주요 수학적 산정 기법
  - **COCOMO 모형**
  - **Putnam 모형**
  - **기능 점수(FP) 모형**

### 21.1. COCOMO 모형
- 원시 프로그램의 규모인 LOC에 의한 비용 산정 기법이다.
- 개발할 소프트웨어의 LOC를 예측한 후, 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정한다.
- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력으로 나타난다.

#### 21.1.1. COCOMO의 소프트웨어 개발 유형
- **조직형**
  - 기관 내부에서 개발된 중•소규모의 소프트웨어이다.
  - 5만 라인 이하의 소프트웨어를 개발하는 유형이다.
  - 사무 처리용, 과학용 응용 소프트웨어 개발에 적합하다.
- **반분리형**
  - 조직형과 내장형의 중간형 소프트웨어이다.
  - 30만 라인 이하의 소프트웨어를 개발하는 유형이다.
  - 컴파일러, 인터프리티와 같은 유틸리티 개발에 적합하다.
- **내장형**
  - 초대형 규모의 소프트웨어이다.
  - 30만 라인 이상의 소프트웨어를 개발하는 유형이다.
  - 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합하다.

#### 21.1.2. COCOMO 모형의 종류
- **기본형**
  - 소프트웨어의 크기와 개발 유형만을 이용하여 비용을 산정한다.
- **중간형**
  - 기본형 COCOMO의 공식을 토대로 사용하나, 다음 4가지 특성에 의해 비용을 산정한다.
    - 제품의 특성
    - 컴퓨터의 특성
    - 개발 요원의 특성
    - 프로젝트의 특성
- **발전형**
  - 중간형 COCOMO를 보완하여 만들어진 모형이다.
  - 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용을 산정한다.
  - 소프트웨어 환경과 구성요소가 사전에 정의되어 있어야 하며, 개발 과정의 후반부에 주로 적용한다.

### 21.2. Putnam 모형
- 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형이다.
- 생명 주기 예측 모형이라고도 한다.
- 시간에 따른 함수로 표현되는 RayLeigh-Norden 곡선의 노력 분포도를 기초로 한다.
- 대형 프로젝트의 노력 분포 산정에 이용된다.
- 개발 기간이 늘어날 수록 프로젝트 적용 인원의 노력이 감소한다.

### 21.3. 기능 점수 모형
- 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능 점수를 산출하며, 총 기능 점수와 영향도를 이용하여 기능 점수를 구한 후 이를 이용해서 비용을 산정하는 기법이다.
- 소프트웨어 기능 증대 요인
  - 자료 입력
  - 정보 출력
  - 명령어
  - 데이터 파일
  - 필요한 루틴과의 인터페이스

### 21.4. 비용 산정 자동화 추정 도구
- **SLIM**
  - RayLeigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구이다.
- **ESTIMACS**
  - 다양한 프로젝트와 개인별 요소를 수용하도록 기능 점수 모형을 지초로 하여 개발된 자동화 추정 도구이다.

## 22. 프로젝트 일정 계획
- 프로젝트의 프로세스를 이루는 소작업을 파악하고 예측된 노력을 각 소작업에 분배하여 소작업의 순서와 일정을 정하는 것이다.
- 프로젝트 일정 계획에 사용되는 기능
  - WBS, PERT/CPM, 간트 차트 등

### 22.1. PERT
- 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크이다.
- 각 작업별로 다음과 같이 단계를 나누어 종료 시기를 결정한다.
  - 낙관적인 경우
  - 가능성이 있는 경우
  - 비관적인 경우
- 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용한다.
- 노드와 간선으로 구성되며 원 노드에는 작업을, 간선에는 낙관치, 기대치, 비관치를 표시한다.
- 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있다.
- 작업 예측치 계산 공식
  - 작업 예측치 = (비관치 + 4 × 기대치 + 낙관치) / 6
  - 평방 편차 = {(비관치 - 낙관치) / 6}²

### 22.2. CPM
- 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법이다.
- CPM은 노드와 간선으로 구성된 네트워크로 노드는 작업을, 간선은 작업 사이의 전후 의존 관계를 나타낸다.
- 원형 노드는 각각의 작업을 의미하며, 작업 이름과 소요 기간을 표시한다.
- 박스 노드는 이정표를 의미하며, 이정표 이름과 예상 완료 시간을 표시한다.
- 간선을 나타내는 화살표의 흐름에 따라 각 작업이 진행되며, 전 작업이 완료되어야 다음 작업을 진행할 수 있다.

### 22.3. 간트 차트
- 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용하여 푝시하는 프로젝트 일정표이다.
- 시간선 차트라고도 한다.
- 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있게 한다.
- 사용자와의 문제점이나 예산의 초과 지출 등도 관리할 수 있게 한다.
- 자원 배치와 인원 계획에 유용하게 사용된다.
- 이정표, 작업 일정, 작업 기간, 산출물로 구성되어 있다.
- 수평 막대의 길이는 각 작업의 기간을 나타낸다.

## 23. 소프트웨어 개발 표준
- 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준을 의미한다.
- 주요 소프트웨어 개발 표준
  - **ISO/IEC 12207**
  - **CMMI**
  - **SPICE**

### 23.1. ISO/IEC 12207
- ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스이다.
- 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.
- ISO/IEC 12207 구분
  - **기본 생명 주기 프로세스**
    - 획득, 공급, 개발, 운영, 유지보수 프로세스
  - **지원 생명 주기 프로세스**
    - 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스
  - **조직 생명 주기 프로세스**
    - 관리, 기반 구조, 훈련, 개선 프로세스

### 23.2. CMMI
- 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델이다.
- CMMI의 소프트웨어 프로세스 성숙도
  1. **초기**
     - 정의된 프로세스 없음
     - 작업자의 능력에 따라 성공 여부가 결정된다.
  2. **관리**
     - 규칙화된 프로세스
     - 특정한 프로젝트 내의 프로세스 정의 및 수행을 한다.
  3. **정의**
     - 표준화된 프로세스
     - 조직의 표준 프록세스를 활용하여 업무를 수행한다.
  4. **정량적 관리**
     - 예측 가능한 프로세스
     - 프로젝트를 정량적으로 관리 및 통제를 한다.
  5. **최적화**
     - 지속적 개선 프로세스
     - 프로세스 역량 향상을 위해 지속적인 프로세스 개선을 한다.

### 23.3. SPICE
- 정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준이다.

#### 23.3.1. SPICE의 구성
- **고객-공급자 프로세스**
  - 소프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성된다.
  - 구성 요소
    - 인수, 공급, 요구 도출, 운영
  - 프로세스 수
    - 10개
- **공학 프로세스**
  - 시스템과 소프트웨어 제품의 명세화, 수현, 유지보수를 하는데 사용되는 프로세스로 구성된다.
  - 구성 요소
    - 개발, 소프트웨어 유지보수
  - 프로세스 수
    - 9개
- **지원 프로세스**
  - 소프트웨어 생명 주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성된다.
  - 구성 요소
    - 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질 문제 해결
  - 프로세스 수
    - 8개
- **관리 프로세스**
  - 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성된다.
  - 구성 요소
    - 관리, 프로젝트 관리, 품질 및 위험 관리
  - 프로세스 수
    - 4개
- **조직 프로세스**
  - 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성된다.
  - 구성 요소
    - 조직 배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정 도구, 재사용
  - 프로세스 수
    - 9개 

#### 23.3.2. SPICE의 프로세스 수행 능력 단계
1. **불완전**
   - 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계이다.
2. **수행**
   - 프로세스가 수행되고 목적이 달성된 단계이다.
3. **관리**
   - 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계이다.
4. **확립**
   - 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계이다.
5. **예측**
   - 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해서 일관되게 수행되는 단계이다.
6. **최적화**
   - 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계이다.

## 24. 소프트웨어 개발 프레임워크
- 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍쳐를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템이다.
- 선행 사업자의 기술에 의존하지 않는 표준화된 개발 기반으로 인해 사업자 중속성이 해소된다.
- 소프트웨어 개발 프레임워크의 주요 기능
  - 예외 처리
  - 트랜잭션 처리
  - 메모리 공유
  - 데이터 소스 관리
  - 서비스 관리
  - 쿼리 서비스
  - 로깅 서비스
  - 사용자 인증 서비스
- 소프트웨어 개발 프레임워크의 종류
  - **스프링 프레임워크**
  - **전자정부 프레임워크**
  - **닷넷 프레임워크**

### 24.1. 스프링 프레임워크
- 자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크이다.
- 동적인 웹 사이트의 개발을 위해 다양한 서비스를 제공한다.
- 전자정부 표준 프레임워크의 기반 기술로 사용되고 있다.

### 24.2. 전자정부 프레임워크
- 대한민국의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍쳐를 제공하는 프레임워크이다.
- 개발 프레임워크의 표준 정립으로 응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목적으로 한다.
- 오픈 소스 기반의 범용화를 이룰 수 있다.
- 공개된 기술을 활용함으로써 특정 업체의 종속성을 배제하고 사업별 공통 컴포넌트 중복 개발을 방지한다.

### 24.3. 닷넷 프레임워크
- Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크이다.
- Microsoft 사에서 통합 인터넷 전력을 위해 개발하였다.
- 코드 실행을 관리하는 CLR이라는 가상머신 상에서 작동한다.

### 24.4. 소프트웨어 개발 프레임워크의 특성
- **모듈화**
  - 프레임워크는 캡슐화를 통해 모듈화를 강화하고 설꼐 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킨다.
  - 프레임워크는 개발 표준에 의한 모듈화로 인해 유지보수가 용이하다.
- **재사용성**
  - 프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능하다.
- **확장성**
  - 프레임워크는 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능하다.
- **제어의 역흐름**
  - 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킨다.